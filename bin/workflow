#!/bin/bash
# jj workflow tool with subcommands
# Can be called directly: workflow create my-feature

# Get the repo root directory
_jj_repo_root() {
    jj root 2>/dev/null || git rev-parse --show-toplevel 2>/dev/null || pwd
}

# Generate a color based on workspace name (using a simple hash)
_jj_generate_color() {
    local name="$1"
    local hash=$(echo -n "$name" | cksum | cut -d' ' -f1)

    # Use modulo 12 for more color variety (30-degree increments)
    local color_index=$((hash % 12))

    # Diverse color palette with maximum visual distinction
    # Colors chosen to be clearly different from each other
    case $color_index in
        0)  echo "60,140,200" ;;  # Blue
        1)  echo "70,180,140" ;;  # Teal
        2)  echo "180,140,60" ;;  # Orange/Gold
        3)  echo "140,70,180" ;;  # Purple
        4)  echo "90,170,90" ;;   # Green
        5)  echo "200,90,120" ;;  # Pink/Magenta
        6)  echo "80,160,190" ;;  # Cyan
        7)  echo "160,120,70" ;;  # Brown/Amber
        8)  echo "100,190,160" ;; # Mint/Aqua
        9)  echo "180,100,60" ;;  # Rust/Orange
        10) echo "110,110,200" ;; # Indigo
        11) echo "70,180,110" ;;  # Sea green
    esac
}

# Create VSCode workspace file with custom colors
_jj_create_workspace_file() {
    local branch_name="$1"
    local repo_root="$(_jj_repo_root)"
    local workspace_file="$repo_root/.jj-workspaces/$branch_name.code-workspace"

    # Get RGB color for this workspace
    local color_rgb=$(_jj_generate_color "$branch_name")

    # Convert RGB to hex format for VSCode
    local color_hex="$(echo $color_rgb | awk -F',' '{printf "#%02x%02x%02x", $1, $2, $3}')"

    # Calculate lighter color, capping at 255
    local color_hex_light="$(echo $color_rgb | awk -F',' '{
        r = int($1*1.3); if (r > 255) r = 255;
        g = int($2*1.3); if (g > 255) g = 255;
        b = int($3*1.3); if (b > 255) b = 255;
        printf "#%02x%02x%02x", r, g, b
    }')"

    cat > "$workspace_file" << EOF
{
  "folders": [
    {
      "path": "$workspace_path"
    }
  ],
  "settings": {
    "workbench.colorCustomizations": {
      "titleBar.activeBackground": "$color_hex",
      "titleBar.activeForeground": "#ffffff",
      "titleBar.inactiveBackground": "${color_hex}99",
      "titleBar.inactiveForeground": "#ffffffcc",
      "statusBar.background": "$color_hex",
      "statusBar.foreground": "#ffffff",
      "statusBar.noFolderBackground": "$color_hex",
      "activityBar.background": "${color_hex}4d",
      "activityBar.foreground": "$color_hex_light"
    }
  }
}
EOF
    echo "  ✓ Created VSCode workspace file with custom colors"
}

# Workspace setup hook - calls project-specific setup if available
_jj_workspace_setup() {
    local workspace_path="$1"
    local repo_root="$(_jj_repo_root)"

    # Run project-specific setup script if it exists
    if [ -f "$repo_root/etc/setup.sh" ]; then
        # Execute with bash to ensure proper escape code handling
        bash "$repo_root/etc/setup.sh" "$workspace_path"
    fi
}

# ============================================================================
# Subcommands
# ============================================================================

workflow_create() {
    if [ -z "$1" ]; then
        echo "Usage: workflow create <workspace-name>"
        return 1
    fi

    local branch_name="$1"
    local repo_root="$(_jj_repo_root)"
    local workspace_path="$repo_root/.jj-workspaces/$branch_name"

    echo "Creating workspace '$branch_name'..."

    # Create the workspace
    jj workspace add "$workspace_path"

    # Run workspace setup (project-specific initialization)
    _jj_workspace_setup "$workspace_path"

    # Create VSCode workspace file with custom colors
    _jj_create_workspace_file "$branch_name"

    echo "✓ Workspace '$branch_name' ready"

    # Open in VSCode
    workflow_open "$branch_name"
}

workflow_open() {
    if [ -z "$1" ]; then
        echo "Usage: workflow open <workspace-name>"
        return 1
    fi

    local branch_name="$1"
    local repo_root="$(_jj_repo_root)"
    local workspace_file="$repo_root/.jj-workspaces/$branch_name.code-workspace"
    local workspace_path="$repo_root/.jj-workspaces/$branch_name"

    # Prefer workspace file if it exists, otherwise open folder
    # Use --new-window to prevent inheriting parent shell's working directory
    if [ -f "$workspace_file" ]; then
        code --new-window "$workspace_file"
        echo "✓ Opened workspace '$branch_name' in VSCode"
    elif [ -d "$workspace_path" ]; then
        code --new-window "$workspace_path"
        echo "✓ Opened workspace '$branch_name' in VSCode (no workspace file found)"
    else
        echo "Error: Workspace '$branch_name' not found"
        return 1
    fi
}

workflow_merge() {
    if [ -z "$1" ]; then
        echo "Usage: workflow merge <workspace-name> [commit-ids...]"
        echo "  If commit-ids are provided, only those commits will be merged"
        echo "  Otherwise, all commits will be merged"
        return 1
    fi

    local branch_name="$1"
    shift
    local selected_commits=("$@")
    local revision="$branch_name"

    # Check if the bookmark exists, if not try with @ suffix (workspace)
    if ! jj log -r "$branch_name" --no-graph 2>/dev/null | grep -q .; then
        if jj log -r "${branch_name}@" --no-graph 2>/dev/null | grep -q .; then
            echo "Note: Using workspace '${branch_name}@' instead of bookmark '$branch_name'"
            revision="${branch_name}@"
        else
            echo "Error: Neither bookmark '$branch_name' nor workspace '${branch_name}@' exists"
            return 1
        fi
    fi

    # If specific commits are selected, merge only those
    if [ ${#selected_commits[@]} -gt 0 ]; then
        echo "Merging selected commits from '$branch_name' into main..."

        # Switch to main
        jj edit main

        # Cherry-pick each selected commit
        for commit_id in "${selected_commits[@]}"; do
            echo "  Merging commit: $commit_id"
            jj squash --from "$commit_id" --into @
        done

        echo "✓ Merged ${#selected_commits[@]} commit(s) from '$branch_name' into main"
    else
        # Original behavior: merge all commits
        echo "Merging all commits from '$branch_name' into main..."

        # Check if there are any commits to merge
        if ! jj log -r "$revision- ~ main" --no-graph 2>/dev/null | grep -q .; then
            echo "Error: No commits to merge from '$branch_name' (workspace is up to date with main)"
            return 1
        fi

        # Rebase workspace commits onto main one by one
        # This creates a linear history without merge commits
        jj rebase -s "$revision-" -d main

        # Move main bookmark to the tip of rebased commits
        jj bookmark set main -r "$revision-"

        # Edit main to update git HEAD
        jj edit main

        echo "✓ Merged '$branch_name' into main (rebased)"
    fi

    echo "  Use 'jj git push' to push to remote"
}

workflow_sync() {
    if [ -z "$1" ]; then
        echo "Usage: workflow sync <workspace-name>"
        return 1
    fi

    local branch_name="$1"
    local workspace="${branch_name}@"

    # Rebase workspace commits onto latest main
    jj rebase -s "$workspace-" -d main

    echo "✓ Synced '$branch_name' with main (rebased)"
}

workflow_flatten() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Usage: workflow flatten <workspace-name> <commit-message>"
        echo "Example: workflow flatten my-feature \"Add new authentication system\""
        return 1
    fi

    local branch_name="$1"
    local commit_message="$2"
    local workspace="${branch_name}@"

    # Get the root commit of the branch (where it diverged from main)
    local base_commit=$(jj log -r "main" --no-graph -T "commit_id" --limit 1)

    # Squash all commits from base to workspace tip
    jj squash --from "($base_commit)::" --to "$workspace" -m "$commit_message"

    echo "✓ Squashed all commits in '$branch_name'"
    echo "  New description: $commit_message"
}

workflow_linearize() {
    if [ -z "$1" ]; then
        echo "Usage: workflow linearize <base-commit> [--squash]"
        echo "Linearizes main by rebasing all commits since <base-commit>"
        echo "  --squash: Squash all commits into one (avoids conflicts)"
        echo "Example: workflow linearize abc123"
        echo "         workflow linearize origin/main --squash"
        return 1
    fi

    local base="$1"
    local squash=false

    if [ "$2" = "--squash" ]; then
        squash=true
    fi

    if [ "$squash" = true ]; then
        echo "Squashing all commits from $base to main..."

        # Create a new commit on base with all changes squashed
        jj new "$base"
        jj restore --from main
        jj describe -m "Squashed history from $base to main"

        # Move main to this new commit
        jj bookmark set main -r @

        echo "✓ Squashed main branch history"
        echo "  All commits have been combined into one"
    else
        echo "Linearizing main branch history from $base..."

        # Rebase all commits between base and main (excluding base itself)
        # Use children() to get commits after the base
        jj rebase -s "($base)+::main" -d "$base"

        echo "✓ Linearized main branch"
        echo "  All merge commits have been flattened into linear history"
        echo "  Note: This may create conflicts that need to be resolved"
    fi

    echo "  Review with 'jj log' before pushing"
}

workflow_delete() {
    if [ -z "$1" ]; then
        echo "Usage: workflow delete <workspace-name>"
        return 1
    fi

    local branch_name="$1"
    local repo_root="$(_jj_repo_root)"
    local workspace_path="$repo_root/.jj-workspaces/$branch_name"
    local workspace_file="$repo_root/.jj-workspaces/$branch_name.code-workspace"
    local workspace="${branch_name}@"

    # Check if workspace exists and has non-empty commits ahead of main
    if jj log -r "$workspace" --no-graph 2>/dev/null | grep -q .; then
        # Check if workspace has non-empty commits ahead of main
        local ahead_count=$(jj log -r "$workspace ~ main" --no-graph -T 'if(!empty, commit_id ++ "\n", "")' 2>/dev/null | grep -c .)
        if [ "$ahead_count" -gt 0 ]; then
            echo "Error: Workspace '${workspace}' has $ahead_count non-empty commit(s) ahead of main"
            echo "Please merge or abandon these commits first"
            return 1
        fi
    fi

    # Remove workspace if it exists
    if [ -d "$workspace_path" ]; then
        local workspace_name=$(basename "$workspace_path")
        jj workspace forget "$workspace_name" 2>/dev/null || true
        rm -rf "$workspace_path"
        echo "✓ Deleted workspace at $workspace_path"
    else
        echo "Note: Workspace at $workspace_path doesn't exist"
    fi

    # Remove workspace file if it exists
    if [ -f "$workspace_file" ]; then
        rm -f "$workspace_file"
        echo "✓ Deleted workspace file at $workspace_file"
    fi
}

workflow_workspaces() {
    jj workspace list
}

workflow_files() {
    local revision="${1:-@}"
    jj diff --summary -r "$revision"
}

workflow_help() {
    cat <<EOF
Jujutsu workflow commands:

  workflow create <name>             Create workspace, open in VSCode
  workflow open <name>               Open existing workspace in VSCode
  workflow merge <name> [commits...] Merge workspace into main
                                     - No commits: merge all changes
                                     - With commits: merge only those commits
  workflow sync <name>               Sync workspace with main (rebase)
  workflow linearize <base-commit>   Linearize main history from base commit
  workflow flatten <name> "message"  Flatten all commits and set description
  workflow delete <name>             Delete workspace (if not ahead)
  workflow workspaces                List all workspaces
  workflow files [revision]          Show modified files (default: @)

Example workflow:
  1. workflow create my-feature
     # Creates workspace and opens in VSCode with unique color
  2. # ... make changes in the workspace ...
  3. workflow open my-feature              # reopen if needed
  4. workflow sync my-feature              # sync with main if needed
  5. workflow flatten my-feature "Add user authentication with JWT"
  6. workflow merge my-feature             # merge all commits into main
     # OR: workflow merge my-feature abc123 def456  # merge specific commits
  7. jj git push                           # push to GitHub

Multi-workspace workflow (work in parallel):
  1. workflow create feature1
  2. workflow create feature2
  3. # Each opens in separate VSCode window with different colors!

Selective merging:
  # View commits in your workspace
  jj log -r 'my-feature@ ~ main'
  # Merge only specific commits
  workflow merge my-feature abc123 def456

EOF
}

# ============================================================================
# Main command dispatcher
# ============================================================================

# Export list of available commands (for meta-wrapper discovery)
workflow_commands() {
    echo "create open merge sync linearize flatten delete workspaces files help"
}

# ============================================================================
# Completion Support
# ============================================================================

# List available workspaces
_workflow_list_workspaces() {
    ls -1 "$(_jj_repo_root)/.jj-workspaces" 2>/dev/null | grep -v '\.code-workspace$' | sort
}

# Return completion options for current position
# Usage: workflow complete <position> <word1> <word2> ...
# Position 1 = completing subcommand, Position 2+ = completing arguments
workflow_complete() {
    local position="$1"
    shift
    local -a words=("$@")

    # Position 1: complete subcommand
    if [ "$position" -eq 1 ]; then
        workflow_commands
        return
    fi

    # Position 2+: complete arguments based on subcommand
    local subcommand="${words[0]}"
    local arg_position=$((position - 1))

    case "$subcommand" in
        create)
            # Arg 1: no completion (freeform workspace name)
            ;;
        open|merge|sync|delete)
            # Arg 1: list available workspaces
            [ "$arg_position" -eq 1 ] && _workflow_list_workspaces
            ;;
        flatten)
            # Arg 1: list available workspaces
            # Arg 2: no completion (freeform commit message)
            [ "$arg_position" -eq 1 ] && _workflow_list_workspaces
            ;;
        linearize|files)
            # Arg 1: no completion (freeform commit/revision)
            ;;
    esac
}

# Main entry point when called directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    cmd="${1:-help}"
    shift || true

    case "$cmd" in
        commands)
            workflow_commands
            ;;
        complete)
            workflow_complete "$@"
            ;;
        create|open|merge|sync|linearize|flatten|delete|workspaces|files|help)
            "workflow_$cmd" "$@"
            ;;
        *)
            echo "Unknown command: $cmd"
            echo "Run 'workflow help' for usage"
            exit 1
            ;;
    esac
fi
